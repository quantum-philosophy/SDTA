setup;

chunks = 30;
totalTime = 1;

config = Optima('001_030');

variants = [ ...
  6.7e-6, 1.9; ... % Cortex-A9
  16e-6, 16e-6 * 30e4; ...
  25e-6, 25e-6 * 35e4; ...
  49e-6, 49e-6 * 40e4; ...
  81e-6, 35 ... % Intel i7 620M
];

variantCount = size(variants, 1);

Error = zeros(chunks, variantCount);
legend = {};

fprintf('%20s%20s%20s%20s%20s%20s%20s%20s\n', ...
  'Area, mm^2', 'Die, mm', 'Spreader, mm', 'Sink, mm', ...
  'Power, W', 'Density, W/cm^2', 'Tce max, C', 'Ths max, C');

for k = 1:variantCount
  processorArea = variants(k, 1);
  maxPower = variants(k, 2);

  config.changeArea(processorArea);
  [ sinkSide, spreaderSide, dieSide ] = config.scalePackage();

  power = Optima.get_power(config.system, config.floorplan, ...
    config.hotspot, config.params, 'deadline_ratio 1');

  [ stepCount, processorCount ] = size(power);

  param_line = Utils.configStream(...
    'deadline_ratio', 1, ...
    'power_scale', maxPower / max(max(power)), ...
    'time_scale', totalTime / (stepCount * config.samplingInterval), ...
    'solution', 'condensed_equation', ...
    'hotspot', 'r_convec 0.2', ...
    'verbose', 0, ...
    'leakage', '');

  for i = 1:chunks
    [ chunkTce, dummy, power, dummy, chunkThs, dummy ] = ...
      Optima.verify(config.system, config.floorplan, ...
        config.hotspot, config.params, param_line, i, 0);

    Error(i, k) = Utils.RMSE(chunkTce, chunkThs);
  end

  legend{end + 1} = [ 'Die ', num2str(processorArea * 1e6), ' mm^2, Power ', ...
    num2str(maxPower),' W' ];

  fprintf('%20.2f%20.2f%20.2f%20.2f%20.f%20.2f%20.2f%20.2f\n', ...
    processorArea * 1e6, dieSide * 1e3, spreaderSide * 1e3, sinkSide * 1e3, ...
    maxPower, maxPower / (processorArea * 1e4), ...
    max(max(chunkTce)) - Constants.degreeKelvin, ...
    max(max(chunkThs)) - Constants.degreeKelvin ...
  );
end

figure;

options = struct( ...
  'xlabel', 'Iterations', ...
  'ylabel', 'Root Mean Square Error', ...
  'marker', true);
options.legend = legend;

Utils.draw(1:chunks, Error, options);
