setup;

chunks = 1:2:30;
totalTime = 1;

config = Optima('001_030');

variants = [ ...
  6.7e-6, 1.9; ... % Cortex-A9
  16e-6, 16e-6 * 30e4; ...
  25e-6, 25e-6 * 35e4; ...
  49e-6, 49e-6 * 40e4; ...
  81e-6, 35 ... % Intel i7 620M
];

chunkCount = length(chunks);
variantCount = size(variants, 1);

Error = zeros(chunkCount, variantCount);
legend = {};

fprintf('%20s%20s%20s%20s%20s%20s%20s%20s\n', ...
  'Area, mm^2', 'Die, mm', 'Spreader, mm', 'Sink, mm', ...
  'Power, W', 'Density, W/cm^2', 'Tce max, C', 'Ths max, C');

for k = 1:variantCount
  processorArea = variants(k, 1);
  maxPower = variants(k, 2);

  config.changeArea(processorArea);
  [ sinkSide, spreaderSide, dieSide ] = config.scalePackage();

  power = Optima.get_power(config.system, config.floorplan, ...
    config.hotspot, config.params, 'deadline_ratio 1');

  [ stepCount, processorCount ] = size(power);

  param_line = @(solution) ...
    Utils.configStream(...
      'deadline_ratio', 1, ...
      'power_scale', maxPower / max(max(power)), ...
      'time_scale', totalTime / (stepCount * config.samplingInterval), ...
      'solution', solution, ...
      'hotspot', 'r_convec 0.2', ...
      'verbose', 0, ...
      'leakage', '');

  for i = 1:chunkCount
    [ chunkTce, power ] = Optima.solve(config.system, config.floorplan, ...
        config.hotspot, config.params, param_line('condensed_equation'));

    chunkTss = Optima.solve(config.system, config.floorplan, ...
        config.hotspot, config.params, param_line('steady_state'));

    Error(i, k) = Utils.RMSE(chunkTce, chunkTss);
  end

  legend{end + 1} = sprintf('%4.1f mm^2, %4.1f W', ...
    processorArea * 1e6, maxPower);

  fprintf('%20.2f%20.2f%20.2f%20.2f%20.f%20.2f%20.2f%20.2f\n', ...
    processorArea * 1e6, dieSide * 1e3, spreaderSide * 1e3, sinkSide * 1e3, ...
    maxPower, maxPower / (processorArea * 1e4), ...
    max(max(chunkTce)) - Constants.degreeKelvin, ...
    max(max(chunkTss)) - Constants.degreeKelvin ...
  );
end

figure;

options = struct( ...
  'xlabel', 'Iterations', ...
  'ylabel', 'Root Mean Square Error', ...
  'marker', true);
options.legend = legend;

Utils.draw(chunks, Error, options);
